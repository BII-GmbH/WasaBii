using System;

namespace BII.Units {

    public readonly struct Interval<T> : IEquatable<Interval<T>>, IComparable<Interval<T>>
        where T : struct, ValueWithUnit, CopyableValueWithUnit<T> {

        public readonly T Min;
        public readonly T Max;

        public readonly bool MinBoundInclusive;
        public readonly bool MaxBoundInclusive;

        public Interval(T a, T b, bool minBoundInclusive = true, bool maxBoundInclusive = true) {
            MinBoundInclusive = minBoundInclusive;
            MaxBoundInclusive = maxBoundInclusive;
            
            if (a.SIValue > b.SIValue) {
                Max = a;
                Min = b;
            } else {
                Max = b;
                Min = a;
            }
        }

        public T Size => default(T).CopyWithDifferentSIValue(Max.SIValue - Min.SIValue);

        public bool Contains(T value) {
           
            var minBorder = MinBoundInclusive
                ? Min.SIValue <= value.SIValue
                : Min.SIValue < value.SIValue;

            var maxBorder = MaxBoundInclusive
                ? value.SIValue <= Max.SIValue
                : value.SIValue < Max.SIValue;

            return minBorder && maxBorder;
        }

        /// (a, b) < (a, b] < [a, b]
        public static bool operator <(Interval<T> a, Interval<T> b) {
            double sizeA = a.Max.SIValue - a.Min.SIValue;
            double sizeB = b.Max.SIValue - b.Min.SIValue;
            
            return sizeA < sizeB 
                || sizeA <= sizeB 
                && (!a.MinBoundInclusive && b.MinBoundInclusive || !a.MaxBoundInclusive && b.MaxBoundInclusive);
        }

        /// [a, b] > [a, b) > (a, b)
        public static bool operator >(Interval<T> a, Interval<T> b) {
            double sizeA = a.Max.SIValue - a.Min.SIValue;
            double sizeB = b.Max.SIValue - b.Min.SIValue;
            
            return sizeA > sizeB
                || sizeA >= sizeB
                && (a.MinBoundInclusive && !b.MinBoundInclusive || a.MaxBoundInclusive && !b.MaxBoundInclusive);
        }

        /// (a, b) < (a, b] < [a, b]
        public static bool operator <=(Interval<T> a, Interval<T> b) {
            double sizeA = a.Max.SIValue - a.Min.SIValue;
            double sizeB = b.Max.SIValue - b.Min.SIValue;
            
            return  sizeA < sizeB 
                || sizeA <= sizeB 
                && !(a.MinBoundInclusive && !b.MinBoundInclusive || a.MaxBoundInclusive && !b.MaxBoundInclusive);
        }
        
        /// [a, b] > [a, b) > (a, b)
        public static bool operator >=(Interval<T> a, Interval<T> b) {
            double sizeA = a.Max.SIValue - a.Min.SIValue;
            double sizeB = b.Max.SIValue - b.Min.SIValue;
            
            return sizeA > sizeB
                || sizeA >= sizeB
                && !(!a.MinBoundInclusive && b.MinBoundInclusive || !a.MaxBoundInclusive && b.MaxBoundInclusive);
        }

        public static bool operator ==(Interval<T> a, Interval<T> b)
            => a.Equals(b);
        
        public static bool operator !=(Interval<T> a, Interval<T> b) => !(a == b);

        public override int GetHashCode() {
            unchecked {
                var hashCode = Min.GetHashCode();
                // Generated by Rider. I don't know why 397.
                hashCode = (hashCode * 397) ^ Max.GetHashCode();
                hashCode = (hashCode * 397) ^ MinBoundInclusive.GetHashCode();
                hashCode = (hashCode * 397) ^ MaxBoundInclusive.GetHashCode();
                return hashCode;
            }
        }

        public bool Equals(Interval<T> other) =>
            Min.Equals(other.Min) 
            && Max.Equals(other.Max) 
            && MinBoundInclusive == other.MinBoundInclusive 
            && MaxBoundInclusive == other.MaxBoundInclusive;
        
        public override bool Equals(object obj) => obj is Interval<T> other && Equals(other);

        public int CompareTo(Interval<T> other) {
            if (this == other) return 0;
            if (this > other) return 1;
            else return -1;
        }
        
        public static Interval<T> MaxSize() => new Interval<T>(
            default(T).CopyWithDifferentSIValue(double.MinValue),
            default(T).CopyWithDifferentSIValue(double.MaxValue)
        );

        public static Interval<T> Zero() => new Interval<T>(
            default(T).CopyWithDifferentSIValue(0),
            default(T).CopyWithDifferentSIValue(0),
            minBoundInclusive: false, maxBoundInclusive: false
        );
    }

    public static class IntervalExtensions {

        public static Interval<T> ToInterval<T>(this (T a, T b) tuple)
            where T : struct, ValueWithUnit, CopyableValueWithUnit<T> 
            => new Interval<T>(tuple.a, tuple.b);
        
    }
}
