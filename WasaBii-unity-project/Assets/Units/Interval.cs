using System;
using BII.WasaBii.Core;
using JetBrains.Annotations;

namespace BII.WasaBii.Units {

    public static class Interval {
        public enum ValueComparison {
            Inside,
            Before,
            After
        }
        public enum IntervalComparison {
            Inside = ValueComparison.Inside,
            Before = ValueComparison.Before,
            After = ValueComparison.After,
            Overlap
        }

        public static bool HasAnyOverlapWith(ValueComparison comp) => comp is ValueComparison.Inside;
        public static bool HasAnyOverlapWith(IntervalComparison comp) => comp is IntervalComparison.Inside or IntervalComparison.Overlap;
    }
    
    [MustBeSerializable][MustBeImmutable]
    public readonly struct Interval<T> : IEquatable<Interval<T>>, IComparable<Interval<T>>
        where T : struct, ValueWithUnit, CopyableValueWithUnit<T> {
        public readonly T Min;
        public readonly T Max;

        public readonly bool MinBoundInclusive;
        public readonly bool MaxBoundInclusive;

        public Interval(T a, T b, bool minBoundInclusive = true, bool maxBoundInclusive = true) {
            MinBoundInclusive = minBoundInclusive;
            MaxBoundInclusive = maxBoundInclusive;

            (Min, Max) = a.SIValue < b.SIValue ? (a, b) : (b, a);
        }

        public T Size => default(T).CopyWithDifferentSIValue(Max.SIValue - Min.SIValue);

        public bool Contains(T value) {
            var minBorder = MinBoundInclusive
                ? Min.SIValue <= value.SIValue
                : Min.SIValue < value.SIValue;

            var maxBorder = MaxBoundInclusive
                ? value.SIValue <= Max.SIValue
                : value.SIValue < Max.SIValue;

            return minBorder && maxBorder;
        }

        /// (a, b) < (a, b] < [a, b]
        public static bool operator <(Interval<T> a, Interval<T> b) {
            double sizeA = a.Max.SIValue - a.Min.SIValue;
            double sizeB = b.Max.SIValue - b.Min.SIValue;
            
            return sizeA < sizeB 
                || sizeA <= sizeB 
                && (!a.MinBoundInclusive && b.MinBoundInclusive || !a.MaxBoundInclusive && b.MaxBoundInclusive);
        }

        /// [a, b] > [a, b) > (a, b)
        public static bool operator >(Interval<T> a, Interval<T> b) {
            double sizeA = a.Max.SIValue - a.Min.SIValue;
            double sizeB = b.Max.SIValue - b.Min.SIValue;
            
            return sizeA > sizeB
                || sizeA >= sizeB
                && (a.MinBoundInclusive && !b.MinBoundInclusive || a.MaxBoundInclusive && !b.MaxBoundInclusive);
        }

        /// (a, b) < (a, b] < [a, b]
        public static bool operator <=(Interval<T> a, Interval<T> b) {
            double sizeA = a.Max.SIValue - a.Min.SIValue;
            double sizeB = b.Max.SIValue - b.Min.SIValue;
            
            return  sizeA < sizeB 
                || sizeA <= sizeB 
                && !(a.MinBoundInclusive && !b.MinBoundInclusive || a.MaxBoundInclusive && !b.MaxBoundInclusive);
        }
        
        /// [a, b] > [a, b) > (a, b)
        public static bool operator >=(Interval<T> a, Interval<T> b) {
            double sizeA = a.Max.SIValue - a.Min.SIValue;
            double sizeB = b.Max.SIValue - b.Min.SIValue;
            
            return sizeA > sizeB
                || sizeA >= sizeB
                && !(!a.MinBoundInclusive && b.MinBoundInclusive || !a.MaxBoundInclusive && b.MaxBoundInclusive);
        }

        public static bool operator ==(Interval<T> a, Interval<T> b)
            => a.Equals(b);
        
        public static bool operator !=(Interval<T> a, Interval<T> b) => !(a == b);

        public override int GetHashCode() {
            unchecked {
                var hashCode = Min.GetHashCode();
                // Generated by Rider. I don't know why 397.
                hashCode = (hashCode * 397) ^ Max.GetHashCode();
                hashCode = (hashCode * 397) ^ MinBoundInclusive.GetHashCode();
                hashCode = (hashCode * 397) ^ MaxBoundInclusive.GetHashCode();
                return hashCode;
            }
        }

        public bool Equals(Interval<T> other) =>
            Min.Equals(other.Min) 
            && Max.Equals(other.Max) 
            && MinBoundInclusive == other.MinBoundInclusive 
            && MaxBoundInclusive == other.MaxBoundInclusive;
        
        public override bool Equals(object obj) => obj is Interval<T> other && Equals(other);

        public int CompareTo(Interval<T> other) {
            if (this == other) return 0;
            if (this > other) return 1;
            else return -1;
        }
        
        public static Interval<T> MaxSize() => new Interval<T>(
            default(T).CopyWithDifferentSIValue(double.MinValue),
            default(T).CopyWithDifferentSIValue(double.MaxValue)
        );

        public static Interval<T> Zero() => new Interval<T>(
            default(T).CopyWithDifferentSIValue(0),
            default(T).CopyWithDifferentSIValue(0),
            minBoundInclusive: false, maxBoundInclusive: false
        );
    }

    public static class IntervalExtensions {

        public static Interval<T> ToInterval<T>(this (T a, T b) tuple) where T : struct, CopyableValueWithUnit<T> =>
            new(tuple.a, tuple.b);
        
        public static bool IsNearly<T>(this Interval<T> self, Interval<T> other)
            where T : struct, CopyableValueWithUnit<T>, IComparable<T> 
            => self.Min.IsNearly(other.Min) && self.Max.IsNearly(other.Max);
        
        public static Interval<T> WithStart<T>(this Interval<T> interval, T newStart) 
            where T : struct, CopyableValueWithUnit<T>, IComparable<T>
            => new Interval<T>(newStart, interval.Max);
        
        public static Interval<T> WithEnd<T>(this Interval<T> interval, T newEnd) 
            where T : struct, CopyableValueWithUnit<T>, IComparable<T>
            => new Interval<T>(interval.Min, newEnd);

        public static Interval.ValueComparison CompareToInterval<T>(this T value, Interval<T> interval)
            where T : struct, CopyableValueWithUnit<T>, IComparable<T> =>
            (value.CompareTo(interval.Min), value.CompareTo(interval.Max)) switch {
                (-1, -1) => Interval.ValueComparison.Before,
                (0, -1) when !interval.MinBoundInclusive => Interval.ValueComparison.Before,
                (1, 1) => Interval.ValueComparison.After,
                (1, 0) when !interval.MaxBoundInclusive => Interval.ValueComparison.After,
                _ => Interval.ValueComparison.Inside
            };
        
        public static Interval.IntervalComparison CompareToInterval<T>(this Interval<T> interval, Interval<T> other) 
            where T : struct, CopyableValueWithUnit<T>, IComparable<T> {
            var start = interval.Min.CompareToInterval(other);
            var end = interval.Max.CompareToInterval(other);
            return (start, end) switch {
                (Interval.ValueComparison.Before, Interval.ValueComparison.After) => Interval.IntervalComparison.Inside,
                (Interval.ValueComparison.Before, Interval.ValueComparison.Inside) => Interval.IntervalComparison.Overlap,
                (Interval.ValueComparison.Inside, Interval.ValueComparison.Inside) => Interval.IntervalComparison.Overlap,
                (Interval.ValueComparison.Inside, Interval.ValueComparison.After) => Interval.IntervalComparison.Overlap,
                (Interval.ValueComparison.After, _) => Interval.IntervalComparison.Before,
                (_, Interval.ValueComparison.Before) => Interval.IntervalComparison.After,
                _ => throw new Exception("No matching comparision found. This should not happen, duh")
            };
        }

        public static double InverseLerp<T>(this Interval<T> interval, T value, bool shouldClamp = true)
            where T : struct, CopyableValueWithUnit<T>, IComparable<T> =>
            UnitUtils.InverseLerp(interval.Min, interval.Max, value, shouldClamp);

        public static double? TryInverseLerp<T>(this Interval<T> interval, T value)
            where T : struct, CopyableValueWithUnit<T>, IComparable<T> =>
            interval.InverseLerp(value, shouldClamp: false) switch {
                var val and >= 0d and <= 1d => val,
                _ => null
            };
        
        [Pure]
        public static Interval<T> Encapsulate<T>(this Interval<T> interval, Interval<T> other)
            where T : struct, CopyableValueWithUnit<T>, IComparable<T>
            => new Interval<T>(
                interval.Min.Min(other.Min),
                interval.Max.Max(other.Max)
            );

        public static Duration Total(this Interval<Duration> interval) => interval.Size;

    }
}
